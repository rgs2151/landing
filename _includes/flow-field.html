<canvas id="flow-field-canvas"></canvas>

<script>
(function() {
  const canvas = document.getElementById('flow-field-canvas');
  const ctx = canvas.getContext('2d');
  
  let width, height;
  let particles = [];
  let attractors = [];
  let cursorAttractor = null;
  const numParticles = 800;
  const particleSpeed = 1.2;
  const attractionStrength = 0.008;
  const flowNoiseScale = 0.003;
  const trailLength = 40;
  
  // Simple noise function (Perlin-like)
  class SimplexNoise {
    constructor() {
      this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
      this.p = [];
      for(let i=0; i<256; i++) this.p[i] = Math.floor(Math.random()*256);
      this.perm = [];
      for(let i=0; i<512; i++) this.perm[i]=this.p[i & 255];
    }
    
    dot(g, x, y) {
      return g[0]*x + g[1]*y;
    }
    
    noise(xin, yin) {
      let n0, n1, n2;
      const F2 = 0.5*(Math.sqrt(3.0)-1.0);
      const s = (xin+yin)*F2;
      const i = Math.floor(xin+s);
      const j = Math.floor(yin+s);
      const G2 = (3.0-Math.sqrt(3.0))/6.0;
      const t = (i+j)*G2;
      const X0 = i-t;
      const Y0 = j-t;
      const x0 = xin-X0;
      const y0 = yin-Y0;
      let i1, j1;
      if(x0>y0) {i1=1; j1=0;}
      else {i1=0; j1=1;}
      const x1 = x0 - i1 + G2;
      const y1 = y0 - j1 + G2;
      const x2 = x0 - 1.0 + 2.0 * G2;
      const y2 = y0 - 1.0 + 2.0 * G2;
      const ii = i & 255;
      const jj = j & 255;
      const gi0 = this.perm[ii+this.perm[jj]] % 12;
      const gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
      const gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
      let t0 = 0.5 - x0*x0-y0*y0;
      if(t0<0) n0 = 0.0;
      else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
      }
      let t1 = 0.5 - x1*x1-y1*y1;
      if(t1<0) n1 = 0.0;
      else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
      }
      let t2 = 0.5 - x2*x2-y2*y2;
      if(t2<0) n2 = 0.0;
      else {
        t2 *= t2;
        n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
      }
      return 70.0 * (n0 + n1 + n2);
    }
  }
  
  const noise = new SimplexNoise();
  let time = 0;
  
  class Particle {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.baseX = x;
      this.baseY = y;
      // Pre-calculated static field from title attractors
      this.staticForceX = 0;
      this.staticForceY = 0;
    }
    
    // Find closest point on a line segment
    closestPointOnLine(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const lengthSq = dx * dx + dy * dy;
      
      if (lengthSq === 0) return { x: x1, y: y1, dist: Math.sqrt((px - x1) ** 2 + (py - y1) ** 2) };
      
      let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;
      t = Math.max(0, Math.min(1, t));
      
      const closestX = x1 + t * dx;
      const closestY = y1 + t * dy;
      const dist = Math.sqrt((px - closestX) ** 2 + (py - closestY) ** 2);
      
      return { x: closestX, y: closestY, dist };
    }
    
    // Calculate static field from attractors (only once)
    calculateStaticField() {
      this.staticForceX = 0;
      this.staticForceY = 0;
      
      attractors.forEach(attractor => {
        let dx, dy, dist;
        
        if (attractor.isRectangle) {
          // Rectangle attractor - find closest point on rectangle boundary
          const rect = attractor.rect;
          let closestX, closestY;
          
          // Clamp particle position to rectangle bounds
          closestX = Math.max(rect.left, Math.min(this.x, rect.right));
          closestY = Math.max(rect.top, Math.min(this.y, rect.bottom));
          
          dx = closestX - this.x;
          dy = closestY - this.y;
          dist = Math.sqrt(dx * dx + dy * dy);
        } else {
          // Point attractor calculation
          dx = attractor.x - this.x;
          dy = attractor.y - this.y;
          dist = Math.sqrt(dx * dx + dy * dy);
        }
        
        if (dist > 0) {
          const dirX = dx / dist;
          const dirY = dy / dist;
          
          const minDist = 10;
          const effectiveDist = Math.max(dist, minDist);
          const fieldStrength = attractor.strength / effectiveDist;
          
          this.staticForceX += dirX * fieldStrength;
          this.staticForceY += dirY * fieldStrength;
        }
      });
    }
    
    update() {
      // Start with pre-calculated static field
      let totalForceX = this.staticForceX;
      let totalForceY = this.staticForceY;
      
      // Add cursor attractor contribution (point attractor)
      if (cursorAttractor) {
        const dx = cursorAttractor.x - this.x;
        const dy = cursorAttractor.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Very large cursor influence - affects nearly the entire canvas
        if (dist > 0) {
          const dirX = dx / dist;
          const dirY = dy / dist;
          
          const minDist = 10;
          const effectiveDist = Math.max(dist, minDist);
          
          // Cursor influence with linear falloff (1/distance) for gradual effect
          const fieldStrength = 10000 / effectiveDist;
          
          totalForceX += dirX * fieldStrength;
          totalForceY += dirY * fieldStrength;
        }
      }
      
      // Normalize the combined vector to get direction
      const totalMag = Math.sqrt(totalForceX * totalForceX + totalForceY * totalForceY);
      
      if (totalMag > 0) {
        this.directionX = totalForceX / totalMag;
        this.directionY = totalForceY / totalMag;
        
        // Invert the strength: stronger field (closer) = shorter arrows
        // Weaker field (farther) = longer arrows
        const maxStrength = 100;
        const invertedStrength = 1 - Math.min(1, totalMag / maxStrength);
        this.strength = Math.max(0.1, invertedStrength); // Keep minimum visibility
      } else {
        this.directionX = 0;
        this.directionY = 0;
        this.strength = 0;
      }
    }
    
    draw() {
      // Always draw if we have a direction
      if (this.directionX === 0 && this.directionY === 0) return;
      
      const lineLength = 20 * this.strength;
      const endX = this.x + this.directionX * lineLength;
      const endY = this.y + this.directionY * lineLength;
      
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = `rgba(0, 0, 0, ${this.strength * 0.3})`;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }
  
  function updateAttractors() {
    attractors = [];
    
    // Get profile photo as rectangle attractor
    const bioPhoto = document.querySelector('.bio__hero');
    if (bioPhoto) {
      const photoRect = bioPhoto.getBoundingClientRect();
      
      attractors.push({
        rect: {
          left: photoRect.left,
          right: photoRect.left + photoRect.width,
          top: photoRect.top,
          bottom: photoRect.top + photoRect.height
        },
        strength: 5000,
        isRectangle: true  // Rectangle attractor
      });
    }
    
    // Get email as point attractor
    const bioEmail = document.querySelector('.bio__email');
    if (bioEmail) {
      const emailRect = bioEmail.getBoundingClientRect();
      
      // Center of the email as a point attractor
      const x = emailRect.left + emailRect.width / 2;
      const y = emailRect.top + emailRect.height / 2;
      
      attractors.push({
        x: x,
        y: y,
        radius: Math.max(emailRect.width, emailRect.height) * 4,
        strength: 5000,
        isPoint: true  // Point attractor, not a line
      });
    }
    
    // Add four corner attractors
    const cornerStrength = 8000;
    const inset = 50; // Move corners slightly inward from edges
    
    // Top-left corner
    attractors.push({
      x: inset,
      y: inset,
      strength: cornerStrength,
      isPoint: true
    });
    
    // Top-right corner
    attractors.push({
      x: window.innerWidth - inset,
      y: inset,
      strength: cornerStrength,
      isPoint: true
    });
    
    // Bottom-left corner
    attractors.push({
      x: inset,
      y: window.innerHeight - inset,
      strength: cornerStrength,
      isPoint: true
    });
    
    // Bottom-right corner
    attractors.push({
      x: window.innerWidth - inset,
      y: window.innerHeight - inset,
      strength: cornerStrength,
      isPoint: true
    });
  }
  
  function resize() {
    // Canvas covers full viewport
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    // Create a grid of stationary particles
    particles = [];
    const spacing = 25; // Distance between particles (increased for performance)
    for (let x = spacing; x < width; x += spacing) {
      for (let y = spacing; y < height; y += spacing) {
        particles.push(new Particle(x, y));
      }
    }
    
    updateAttractors();
    
    // Pre-calculate static fields for all particles (performance optimization)
    particles.forEach(particle => {
      particle.calculateStaticField();
    });
  }
  
  function animate() {
    ctx.clearRect(0, 0, width, height);
    
    // Draw particles in batches to prevent long blocking operations
    const batchSize = 200;
    for (let i = 0; i < particles.length; i += batchSize) {
      const batch = particles.slice(i, i + batchSize);
      batch.forEach(particle => {
        particle.update();
        particle.draw();
      });
    }
    
    requestAnimationFrame(animate);
  }
  
  // Initialize
  window.addEventListener('resize', () => {
    resize();
  });
  
  // Throttle mouse movement to reduce calculations
  let mouseThrottle = null;
  window.addEventListener('mousemove', (e) => {
    if (mouseThrottle) return;
    
    mouseThrottle = setTimeout(() => {
      mouseThrottle = null;
    }, 16); // ~60fps
    
    const rect = canvas.getBoundingClientRect();
    cursorAttractor = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  });
  
  // Remove cursor attractor when mouse leaves window
  window.addEventListener('mouseleave', () => {
    cursorAttractor = null;
  });
  
  // Update attractor positions on scroll
  let scrollThrottle = null;
  window.addEventListener('scroll', () => {
    if (scrollThrottle) return;
    
    scrollThrottle = setTimeout(() => {
      scrollThrottle = null;
      // Recalculate static fields when attractors move
      updateAttractors();
      particles.forEach(particle => {
        particle.calculateStaticField();
      });
    }, 100);
  });
  
  // Observe viewport resize
  const resizeObserver = new ResizeObserver(() => {
    if (window.innerHeight !== height || window.innerWidth !== width) {
      resize();
    }
  });
  
  // Wait for content to load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        resize();
        animate();
        
        resizeObserver.observe(document.body);
        
        // Recalculate after images load
        window.addEventListener('load', () => {
          setTimeout(() => {
            updateAttractors();
            particles.forEach(particle => {
              particle.calculateStaticField();
            });
          }, 200);
        });
      }, 100);
    });
  } else {
    setTimeout(() => {
      resize();
      animate();
      
      resizeObserver.observe(document.body);
      
      // Recalculate after images load
      window.addEventListener('load', () => {
        setTimeout(() => {
          updateAttractors();
          particles.forEach(particle => {
            particle.calculateStaticField();
          });
        }, 200);
      });
    }, 100);
  }
})();
</script>

<style>
#flow-field-canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  z-index: 0;
  pointer-events: none;
}

.container {
  position: relative;
  z-index: 1;
  min-height: 100vh;
}

@media (max-width: 768px) {
  #flow-field-canvas {
    display: none;
  }
}
</style>
